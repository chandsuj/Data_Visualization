# -*- coding: utf-8 -*-
"""DataVisualization_CW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17b8vKj8gMQOQ6CDZzAagwWLJC897VEgj
"""

!pip install hvplot

#importing libraries
import pandas as pd
import matplotlib.pyplot as plt
# matplotlib for plotting the plots
import numpy as np
import seaborn as sns
import holoviews as hv
import hvplot.pandas

#reading all the data

#weekly number of customers visit to each of the company's cinema
cinema_weekly_visitors = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaWeeklyVisitors.csv', index_col=0)

#The average age of visitors at each cinema
visitors_age_avg = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaAge.csv', index_col=0)

#The seating capacity for each cinema
seating_capacity = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaCapacity.csv', index_col = 0)

#The average annual spend on local marketing for each cinema
annual_marketing_avg = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaMarketing.csv', index_col= 0)

#The average annual overheads for each cinema
annual_overheads_avg = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaOverheads.csv', index_col= 0)

#The average spend (£) by visitors at each cinema
vititors_spend_avg = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaSpend.csv', index_col = 0)

# trying to calculate the revenue per visitors :

print(cinema_weekly_visitors)
print(visitors_age_avg)
print(seating_capacity)
print(annual_marketing_avg)
print(annual_overheads_avg)
print(vititors_spend_avg)


#one  dataframe containing customer data (one row for each date)
data = pd.read_csv('https://tinyurl.com/ChrisCoDV/001330754/CinemaWeeklyVisitors.csv', index_col= 0)
pd.plotting.register_matplotlib_converters()

customer_data = data
customer_data.index = pd.to_datetime(customer_data.index)
# convert the index to date objects
# print(data.index)


# customer_data = pd.DataFrame(index=data.columns)

print(customer_data)

print(customer_data.head(70))
# print(customer_data.head())
# print(customer_data.describe())
customer_data_sorted = customer_data.reindex(data.sum().sort_values(ascending= False).index, axis=1)
# sort the data according to the sum of each column,largest first
# print('Sorted data',customer_data_sorted)


# creating the summary data

summary_data = pd.DataFrame(index=data.columns)

summary_data['visitors_age_avg'] = visitors_age_avg.values
summary_data['annual_visitors_avg'] = cinema_weekly_visitors.mean().values * 52
summary_data['visitors_spend_avg'] = vititors_spend_avg.values
summary_data['seating_capacity'] = seating_capacity.values


summary_data['annual_marketing_avg']=annual_marketing_avg.values
summary_data['annual_overheads_avg'] = annual_overheads_avg.values



# Profit=(Annual Visitors Avg×Visitors Spend Avg)−(Annual Marketing Avg+Annual Overheads Avg)

# Calculate profit
summary_data['annual_profit'] = ((summary_data['annual_visitors_avg'] * summary_data['visitors_spend_avg']) -
                          (summary_data['annual_marketing_avg'] + summary_data['annual_overheads_avg']))





print("Summary data",summary_data)
print(summary_data.head())

print(summary_data.describe())

# piechart of the total cinema visitors.
# sort the data according to the sum of each column
data = customer_data.reindex(customer_data.sum().sort_values(ascending=False).index, axis=1)
print(data.head())

explodeList = []
selected = []
columns = data.columns
data['Others'] = [0] * len(data.index)
for name in columns:
    total_visitors = data[name].sum()
    if total_visitors > 50_000:
        selected.append(name)
        explodeList.append(0)
    else:
        data['Others'] += data[name]
selected.append('Others')
explodeList.append(0.05)
print(data[selected].head())

plt.figure(figsize=(8, 8))
plt.pie(data[selected].sum(), labels=selected, autopct='%1.1f%%', startangle=90, explode=explodeList)
plt.title('Total cinema visitors', fontsize=20)
plt.legend(loc=2)
plt.show()

data = customer_data.reindex(customer_data.sum().sort_values(ascending= False).index, axis=1)

selected = []
columns = data.columns
data['Others'] = [0] * len(data.index)
for name in columns:
    total_visitors = data[name].sum()
    if total_visitors > 10000:
        selected.append(name)
    else:
        data['Others'] += data[name]
selected.append('Others')
# print(data[selected].head())

plt.figure(figsize=(8, 8))
x_pos = np.arange(len(selected))
plt.bar(x_pos, data[selected].sum(), align='center')
plt.xticks(x_pos, selected, rotation = 90)
plt.xlabel('Cinemas', fontsize=18)
plt.ylabel('Customer visits', fontsize=18)
plt.title('Total customer visits', fontsize=20)
plt.show()
# decide the limits (by urself.)
# done for now

colours = []
for name in data.columns:
    total_sales = data[name].sum()
    if total_sales > 150000:
        colour = 'green'
    elif total_sales > 50000:
        colour = 'yellow'
    elif total_sales > 20000:
        colour = 'blue'
    else:
        colour = 'red'
    colours.append(colour)

plt.figure(figsize=(8, 8))
x_pos = np.arange(len(data.columns))
plt.bar(x_pos, data.sum(), align='center', color=colours)
plt.xticks(x_pos, data.columns, rotation = 90)
plt.xlabel('Cinemas', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Segmentation according to customer visits', fontsize=20)
plt.show()

# Categorisation of the visitors in 5 category.
categories = ['High', 'Medium', 'Low', 'Very Low']
categories_selected = [[] for i in range(len(categories))]

for name in data.columns:
    total_visitors = data[name].sum()
    if total_visitors > 125000:
        category = 0
    elif total_visitors > 50000:
        category = 1
    elif total_visitors > 20000:
        category = 2
    else:
        category = 3
    categories_selected[category].append(name)
    print( name + ' is ' + categories[category] + ' volume')

for i in range(len(categories)):
  print(categories[i] + ': ' + str(categories_selected[i]))

for i, selected in enumerate(categories_selected):
    plt.figure(figsize=(8, 8))
    x_pos = np.arange(len(data[selected].columns))
    plt.bar(x_pos, data[selected].mean(), align='center')
    plt.xticks(x_pos, data[selected].columns, rotation = 90)
    plt.xlabel('Cities', fontsize=18)
    plt.ylabel('Visitors ', fontsize=18)
    plt.title(categories[i] + ' Volume visitors', fontsize=20)
    plt.show()

pd.plotting.register_matplotlib_converters()
customer_data.index = pd.to_datetime(customer_data.index)
print(data.head())

# data.plot.line(linewidth=0.5, figsize=(8, 8))
plt.figure(figsize=(8, 8))
plt.plot(customer_data, linewidth=0.5)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Daily visitors', fontsize=20)
# plt.legend(data.columns, loc=2)
plt.show()

plot = customer_data.corr().hvplot.heatmap(
    frame_height=500, frame_width=500,
    title='Cinemas correlation',
    rot=90, cmap='coolwarm'  # see http://holoviews.org/user_guide/Colormaps.html
).opts(invert_yaxis=True, clim=(-1, 1))
hv.extension('bokeh')
plot

period = 7
rolling_average = customer_data.rolling(window=period).mean()
selected = ['YBS', 'VJV', 'VPG', 'WVA']
# High: ['YBS', 'VJV', 'VPG', 'WVA']
# Medium: ['WBK', 'TPY', 'TJN', 'UVQ']
# Low: ['UDD', 'RPQ', 'SJE', 'TVJ', 'WQW', 'XWO', 'JJQ', 'YKT', 'ACQ', 'XEZ', 'XQE', 'ZWY', 'YCI', 'WKL']
# Very Low: ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN', 'Others']

print(customer_data[selected].head())



# data.plot.line(linewidth=0.5, figsize=(8, 8))
plt.figure(figsize=(8, 8))

plt.plot(customer_data[selected], linewidth=0.5)

plt.gca().set_prop_cycle(None)
plt.plot(rolling_average[selected], linewidth=2)
# plt.ylim(ymin=0)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Customer visits', fontsize=18)
plt.title('Total customer visits with 7-day Rolling Average', fontsize=20)
plt.legend(customer_data.columns, loc=2)
plt.show()



"""**The topic we need to explore are correlations, seasional behaviour and outliers.**

Together with a suggesOon about how the data might be best **segmented**, based on the total volume of visits at each cinema. The company is most interested in the **high and medium volume cinemas** but would like a summary of the **low volume cinemas plus any anomalies you idenOfy in the data.** You should also idenOfy **new cinemas that have been opened over the period or cinemas that the company has closed over the period.** You should present your findings in the form of a pdf report for the company, i.e. based on the assumpOon that the reader knows nothing about data visualisation.

**Correlation** refers to the mutual relation between the two or more things .
"""

# high  volume visitors
data_sorted = customer_data.reindex(data.mean().sort_values(ascending=False).index, axis=1)

selected = ['YBS', 'VJV', 'VPG', 'WVA']


print(customer_data[selected].head())

# data[selected].plot.line(linewidth=0.5, figsize=(8, 8))
plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.xlabel('Date', fontsize=16)
plt.ylabel('Visitors ', fontsize=16)
plt.title('High Volume visitors per date', fontsize=20)
plt.legend(selected, loc=2)
plt.show()

# sns.pairplot(summary_data, height=1.5, plot_kws={'s': 20})
# plt.show()

# medium  volume visitors
data_sorted = customer_data.reindex(data.mean().sort_values(ascending=False).index, axis=1)

selected = ['WBK', 'TPY', 'TJN', 'UVQ', 'UDD', 'RPQ', 'SJE', 'TVJ']



print(customer_data[selected].head())

# data[selected].plot.line(linewidth=0.5, figsize=(8, 8))
plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.xlabel('Date', fontsize=16)
plt.ylabel('Visitors ', fontsize=16)
plt.title('Medium Volume visitors per date', fontsize=20)
plt.legend(selected, loc=2)
plt.show()

"""The previous chart is a little overcrowded, so create a further chart for medium volume pages which also includes a 14-day rolling average for each time series."""

# high volume
period = 14
rolling_average = data.rolling(window=period).mean()

selected = ['YBS', 'VJV', 'VPG', 'WVA']
print(customer_data[selected].head())

plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.gca().set_prop_cycle(None)
plt.plot(rolling_average[selected], linewidth=2)
# plt.ylim(ymin=0)
plt.xlabel('Date', fontsize=16)
plt.ylabel('Visitors', fontsize=16)
plt.title('High Volume visitors with 14-day Rolling Average', fontsize=18)
plt.legend(selected, loc=2)
plt.show()

# medium volume
period = 14
rolling_average = data.rolling(window=period).mean()

selected = ['WBK', 'TPY', 'TJN', 'UVQ', 'UDD', 'RPQ', 'SJE', 'TVJ']
print(customer_data[selected].head())

plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.gca().set_prop_cycle(None)
plt.plot(rolling_average[selected], linewidth=2)
# plt.ylim(ymin=0)
plt.xlabel('Date', fontsize=16)
plt.ylabel('Visitors', fontsize=16)
plt.title('Medium  Volume visitors with 14-day Rolling Average', fontsize=18)
plt.legend(selected, loc=2)
plt.show()

"""A further chart for medium volume pages which also includes a trendline (so it should show the original time series, 14-day rolling average and trendline combined).
The trendline a dashed line rather than continuous

"""

selected = ['WBK', 'TPY', 'TJN', 'UVQ', 'UDD', 'RPQ', 'SJE', 'TVJ']

plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.plot(rolling_average[selected], linewidth=2)
plt.gca().set_prop_cycle(None)
for name in selected:
    x = np.arange(len(customer_data[name]))
    z = np.polyfit(x, customer_data[name], 1)
    trend = np.poly1d(z)
    plt.plot(customer_data.index, trend(x), linestyle='--')
# plt.ylim(ymin=0)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Medium Volume visits with 14-day Rolling Average and Trendlines', fontsize=20)
plt.legend(selected, loc=2)
plt.show()

selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']

plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.plot(rolling_average[selected], linewidth=2)
plt.gca().set_prop_cycle(None)
for name in selected:
    x = np.arange(len(customer_data[name]))
    z = np.polyfit(x, customer_data[name], 1)
    trend = np.poly1d(z)
    plt.plot(customer_data.index, trend(x), linestyle='--')
# plt.ylim(ymin=0)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Very low  Volume visits with 14-day Rolling Average and Trendlines', fontsize=20)
plt.legend(selected, loc=2)
plt.show()

#  very lowmedium volume
period = 14
rolling_average = data.rolling(window=period).mean()

selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']
# print(customer_data[selected].head())

plt.figure(figsize=(8, 8))
plt.plot(customer_data[selected], linewidth=0.5)
plt.gca().set_prop_cycle(None)
plt.plot(rolling_average[selected], linewidth=2)
# plt.ylim(ymin=0)
plt.xlabel('Date', fontsize=16)
plt.ylabel('Visitors', fontsize=16)
plt.title('Low Volume visitors with 14-day Rolling Average', fontsize=18)
plt.legend(selected, loc=2)
plt.show()

"""There is information about open and closed cinema so lets explore further and use interactive one."""

period = 14
rolling_average = customer_data.rolling(window=period).mean()

selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']

# Create a combined hvPlot with both the raw data and the rolling average.
# We will plot the raw data with a lower opacity to differentiate it from the rolling average.
# you can hover, zoom ,  choose any labels that we are intrested in,
# use interactive way to extract the detail information on it.
plot = customer_data[selected].hvplot.line(
    ylabel='Visitors', xlabel='Date',
    title='Low Volume Visitors with 14-day Rolling Average',
    width=600, height=500,
    line_width=0.5, alpha=0.4
) * rolling_average[selected].hvplot.line(
    line_width=2
)

#  extensions for interactive features
hv.extension('bokeh')

# Show the plot
plot

# interactive plot to find the shutdown cinema and open which was found in very low volume.
selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']
plot = data.hvplot.line(
    frame_height=500, frame_width=500,
    xlabel='Date', ylabel='Visitors',
    title='Very low volume cinemas'
)
hv.extension('bokeh')
plot

selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']
plot = customer_data[selected].hvplot.line(
    frame_height=500, frame_width=500,
    xlabel='Date', ylabel='Visitors',
    title=' cinemas with anamoly'
)
hv.extension('bokeh')
plot

"""**Customer visits correlation.**
Scatter plot and heat map are the best way to check the correlation.
"""

selected =  ['YBS', 'VJV', 'VPG', 'WVA']


counter = 1
fig = plt.figure(figsize=(12, 12))
fig.suptitle(' High volume  visitors  correlations', fontsize=14, position=(0.5, 1.0))
for i, name_i in enumerate(selected):
    for j in range(i + 1, len(selected)):
        name_j = selected[j]
        sub = fig.add_subplot(3, 3, counter)
        sub.set_title(name_i + ' vs ' + name_j, fontsize=10)
        sub.scatter(customer_data[name_i], data[name_j], s=0.5)
        counter += 1
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.tight_layout()
plt.show()

selected =  ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']


counter = 1
fig = plt.figure(figsize=(10, 10))
fig.suptitle(' low visitors  correlations', fontsize=14, position=(0.5, 1.0))
for i, name_i in enumerate(selected):
    for j in range(i + 1, len(selected)):
        name_j = selected[j]
        sub = fig.add_subplot(6, 6, counter)
        sub.set_title(name_i + ' vs ' + name_j, fontsize=10)
        sub.scatter(customer_data[name_i], data[name_j], s=0.5)
        counter += 1
plt.subplots_adjust(wspace=0.5, hspace=0.5)
plt.tight_layout()
plt.show()

import seaborn as sns
plt.figure(figsize=(8, 8))
pd.plotting.register_matplotlib_converters()

selected =  ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']
print(customer_data[selected].head())

plt.figure(figsize=(6, 6))
corr = customer_data[selected].corr()
ax = sns.heatmap(corr, vmin=-1, vmax=1, center=0, cmap=sns.diverging_palette(220, 20, n=200), square=True, annot=True,
                 annot_kws={"size": 8})
ax.set_xticklabels(ax.get_xticklabels(), rotation=45, horizontalalignment='right')
plt.title(' Very Low Volume visitors heatmap', fontsize=15)

plt.show()

xlimits = (20, 100)
ylimits = (20, 100)
plot = data.hvplot.scatter(
    frame_height=300, frame_width=300,
    x='ZQL', y='BWF', xlabel='', ylabel='',
    xlim=xlimits, ylim=ylimits, size=10
) * \
data.hvplot.scatter(
    frame_height=300, frame_width=300,
    x='BKK', y='CCX', xlabel='', ylabel='',
    xlim=xlimits, ylim=ylimits, size=10
) * \
data.hvplot.scatter(
    frame_height=300, frame_width=300,
    x='CWN', y='SDT', xlabel='', ylabel='',
    xlim=xlimits, ylim=ylimits, size=10
)
hv.extension('bokeh')
plot

# cinema correlation found in low volume
selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']

plot = customer_data[selected].corr().hvplot.heatmap(
    frame_height=500, frame_width=500,
    title='Cinema correlations',
    rot=90, cmap='coolwarm'  # see http://holoviews.org/user_guide/Colormaps.html
).opts(invert_yaxis=True, clim=(-1, 1))
hv.extension('bokeh')
plot

# ZQL and BWF has the strongest correlation.

selected = customer_data.columns[customer_data.sum()> 1000]
n_selected = len(selected)
print(selected)

# Calculate the number of rows needed based on the number of selected columns
n_rows = (n_selected + 1) // 2  # +1 to ensure an extra row for an odd number of selected columns

fig, axes = plt.subplots(figsize=(8, n_rows * 2), nrows=n_rows, ncols=2)
fig.suptitle('Autocorrelation plots', fontsize=20, position=(0.5, 0.90))

# Flatten the axes array for easier indexing
axes_flat = axes.flatten()

for i, name in enumerate(selected):
    sub = pd.plotting.autocorrelation_plot(customer_data[name], ax=axes_flat[i])
    sub.set_title(name, fontsize=10)
    sub.xaxis.label.set_visible(False)
    sub.yaxis.label.set_visible(False)

# Adjust layout
plt.subplots_adjust(wspace=0.5, hspace=0.5)

# Hide any unused axes if the number of selected columns is odd
if n_selected % 2:
    axes_flat[-1].set_visible(False)

plt.show()

"""**A single visualisation showing line subplots for all high and medium volume pages. Trying to detect any quarterly (or other large-scale) seasonality**"""

for name in selected:

  pd.plotting.autocorrelation_plot(customer_data[name])
  plt.title(name)
  plt.show()

# seasonality
from statsmodels.tsa.seasonal import seasonal_decompose

selected = ['UDD', 'TJN', 'RPQ', 'WVA']

for name in selected:
    result = seasonal_decompose(data[name], model='multiplicative', period=50)
    result.plot()
    plt.suptitle( 'Seasonality by seasonal decompose', position=(0.5, 1.0))
    plt.show()
# we can see the seasonality as the peak is there in every new year.

# boxplot to see the outliers for the medium volume visitors.
selected = ['WBK', 'TPY', 'TJN', 'UVQ', 'UDD', 'RPQ', 'SJE', 'TVJ']
plt.figure(figsize=(8, 8))
# data[selected].boxplot()

plt.boxplot(customer_data[selected], labels=selected)
plt.xlabel('Cinema', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Medium volume visitors  distributions using boxplots', fontsize=18)
plt.show()

# boxplot to see the outliers for the high volume visitors.
selected =  ['YBS', 'VJV', 'VPG', 'WVA']
plt.figure(figsize=(8, 8))
# data[selected].boxplot()
plt.boxplot(customer_data[selected], labels=selected)
plt.xlabel('Cinema', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('High volume visitors  distributions using boxplots', fontsize=18)
plt.show()

# Low: ['UDD', 'RPQ', 'SJE', 'TVJ', 'WQW', 'XWO', 'JJQ', 'YKT', 'ACQ', 'XEZ', 'XQE', 'ZWY', 'YCI', 'WKL']
# boxplot to see the outliers for the low volume visitors.
selected = ['UDD', 'RPQ', 'SJE', 'TVJ', 'WQW', 'XWO', 'JJQ', 'YKT', 'ACQ', 'XEZ', 'XQE', 'ZWY', 'YCI', 'WKL']
plt.figure(figsize=(8, 8))
# data[selected].boxplot()
plt.boxplot(customer_data[selected], labels=selected)
plt.xlabel('Cinema', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Low volume visitors  distributions using boxplots', fontsize=18)
plt.show()

# Very Low: ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN', 'Others']
selected = ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN']
plt.figure(figsize=(8, 8))
# data[selected].boxplot()
plt.boxplot(customer_data[selected], labels=selected)
plt.xlabel('Cinema', fontsize=18)
plt.ylabel('Visitors', fontsize=18)
plt.title('Very low volume visitors  distributions using boxplots', fontsize=18)
plt.show()

"""**SUMMARY DATA**

"""

plt.figure(figsize=(10, 10))
corr = summary_data.corr()
ax = sns.heatmap(corr, vmin=-1, vmax=1, center=0, cmap=sns.diverging_palette(220, 20, n=200), square=True, annot=True,
                 annot_kws={"size": 8})
ax.set_xticklabels(ax.get_xticklabels(), rotation=45, horizontalalignment='right')
plt.show()

selected =  ['YBS', 'VJV', 'VPG', 'WVA']
selected_summary_data = summary_data.loc[selected]

plt.figure(figsize=(6, 6))
counter = 1
x_pos = np.arange(len(selected_summary_data.index))
for attribute in selected_summary_data:
    sub = plt.subplot(3, 3, counter)
    sub.bar(x_pos, selected_summary_data[attribute], align='center')
    sub.set_xticks([])
    sub.set_xticks(x_pos)
    sub.set_xticklabels(selected_summary_data.index, rotation=90)
    sub.set_xlabel('Cinemas', fontsize=10)
    sub.set_ylabel(attribute, fontsize=10)
    counter += 1
plt.suptitle('Cinema Attributes Comparison', fontsize=15)
plt.tight_layout()
plt.show()

sns.pairplot(summary_data, height=1.5, plot_kws={'s': 20})
plt.show()

"""NORMALISATION:
Firstly we normalise the data so that everything has the same scale.
Value lies between 0 and 1.
normalised_data = summary_data/summary_data.max()
"""

# Medium: ['WBK', 'TPY', 'TJN', 'UVQ']
# Low: ['UDD', 'RPQ', 'SJE', 'TVJ', 'WQW', 'XWO', 'JJQ', 'YKT', 'ACQ', 'XEZ', 'XQE', 'ZWY', 'YCI', 'WKL']
# Very Low: ['BWF', 'ZQL', 'BKK', 'BQV', 'AKA', 'CCX', 'SDT', 'CWN', 'Others']


# comparative bar plot  for high volume.
normalised_data = summary_data/summary_data.max()
selected =  ['YBS', 'VJV', 'VPG', 'WVA']

colours = ['r','b', 'g','y']
plt.figure(figsize=(5, 5))
c = 0
n_bars = len(selected)
x_pos_base = np.arange(len(summary_data.columns))
bar_width = 0.8 / n_bars
for name in selected:
    values = normalised_data.loc[[name]].values.flatten().tolist()
    x_pos = [x + (bar_width * c) for x in x_pos_base]
    plt.bar(x_pos, values, color=colours[c % len(colours)],
            width=bar_width, edgecolor='white', label= name)
    c += 1
x_pos = [x + (bar_width * (c - 1) / 2) for x in x_pos_base]
plt.xticks(x_pos, summary_data.columns, rotation=90)
plt.title('Comparative Normalized Data for High Volume Cinemas', fontsize=14)
plt.legend(title='Cinema', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

selected =  ['YBS', 'VJV', 'VPG', 'WVA']
# Medium: ['WBK', 'TPY', 'TJN', 'UVQ']

# What you will notice is that some of the metrics are too small to distinguish from each other.
# This is because (assuming you have adapted one of the lecture examples)
# some of the metrics are being normalised by very large values from the high volume pages.
# Instead it makes more sense to normalise by the maximum value from medium volume pages only since the visualisation is restricted to these pages.
# To do this create a normalised data frame using:
# normalised_data = summary_data / summary_data.loc[selected].max() where "selected" contains the list of medium volume pages.

normalised_data = summary_data / summary_data.loc[selected].max()


n_attributes = len(summary_data.columns)
angles = [n / float(n_attributes) * 2 * np.pi for n in range(n_attributes + 1)]
plt.figure(figsize=(8, 8))
counter = 1
for name in selected:
    # values = normalised_data.transpose()[name].values.flatten().tolist()
    values = normalised_data.loc[[name]].values.flatten().tolist()
    values += values[:1]
    sub = plt.subplot(2, 2, counter, polar=True)
    sub.plot(angles, values)
    sub.fill(angles, values, alpha=0.2)
    sub.set_ylim(ymax=1.05)
    sub.set_yticks([0.2, 0.4, 0.6, 0.8, 1.0])
    sub.set_xticks(angles[0:-1])
    sub.set_xticklabels(normalised_data.columns, fontsize=8)
    sub.set_title('Cinema ' + name, fontsize=15, loc='left')
    counter += 1
plt.tight_layout()
plt.show()

# High:
selected = ['YBS', 'VJV', 'VPG', 'WVA']
normalised_data = summary_data / summary_data.loc[selected].max()


n_attributes = len(normalised_data.columns)
angles = [n / float(n_attributes) * 2 * np.pi for n in range(n_attributes + 1)]
colours = ['b', 'g', 'r', 'c']
c = 0
plt.figure(figsize=(6, 6))
sub = plt.subplot(1, 1, 1, polar=True)
for name in selected:
    values = normalised_data.loc[[name]].values.flatten().tolist()
    values += values[:1]
    sub.plot(angles, values, colours[c % len(colours)], label=name)
    sub.fill(angles, values, colours[c % len(colours)], alpha=0.1)
    sub.set_ylim(ymax=1.05)
    sub.set_yticks([0.2, 0.4, 0.6, 0.8, 1.0])
    sub.set_xticks(angles[0:-1])
    sub.set_xticklabels(normalised_data.columns)
    c += 1
plt.title("High Volume Cinema Radar Plot")
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

# Medium:
selected =  ['WBK', 'TPY', 'TJN', 'UVQ']

normalised_data = summary_data / summary_data.loc[selected].max()


n_attributes = len(normalised_data.columns)
angles = [n / float(n_attributes) * 2 * np.pi for n in range(n_attributes + 1)]
colours = ['b', 'g', 'r', 'c']
c = 0
plt.figure(figsize=(6, 6))
sub = plt.subplot(1, 1, 1, polar=True)
for name in selected:
    values = normalised_data.loc[[name]].values.flatten().tolist()
    values += values[:1]
    sub.plot(angles, values, colours[c % len(colours)], label= name)
    sub.fill(angles, values, colours[c % len(colours)], alpha=0.1)
    sub.set_ylim(ymax=1.05)
    sub.set_yticks([0.2, 0.4, 0.6, 0.8, 1.0])
    sub.set_xticks(angles[0:-1])
    sub.set_xticklabels(normalised_data.columns)
    c += 1
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

# summary_data

print(summary_data.head())
print(summary_data.describe())

summary_data['BubbleSize'] = summary_data['annual_marketing_avg'] * 20

plt.figure(figsize=(8, 8))
plt.scatter(summary_data['annual_visitors_avg'], summary_data['seating_capacity'], s=summary_data['BubbleSize'], alpha=0.5)
plt.title('Seating Capacity vs Annual Visitors vs Marketing', fontsize=20)
plt.xlabel('Annual Visitors', fontsize=18)
plt.ylabel('Seating Capacity', fontsize=18)

for i, name in enumerate(summary_data.index):
    plt.annotate(name + ' (£' + str(int(summary_data['annual_marketing_avg'][i])) + ')',
                 (summary_data['annual_visitors_avg'][i] + 300, summary_data['seating_capacity'][i]))
plt.plot([0, 55000], [0, 200], linestyle=':', color='black', label='£2.00 per unit')
plt.plot([0, 55000], [0, 300], linestyle=':', color='red', label='£1.00 per unit')
plt.plot([0, 55000], [0, 400], linestyle=':', color='orange', label='£0.50 per unit')
plt.plot([0, 55000], [0, 500], linestyle=':', color='green', label='£0.25 per unit')
plt.legend(loc=2, title='Marketing spend limits')
plt.show()

print(summary_data)
# print(summary_data.describe())

summary_data['BubbleSize'] = summary_data['annual_marketing_avg'] * 50

plt.figure(figsize=(8, 8))
plt.scatter(summary_data['seating_capacity'], summary_data['annual_visitors_avg'], s=summary_data['BubbleSize'], alpha=0.5)
plt.title('Seating Capacity vs Annual Visitors vs Marketing', fontsize=20)
plt.xlabel('Seating Capacity', fontsize=18)
plt.ylabel('Annual Visitors', fontsize=18)

for i, name in enumerate(summary_data.index):
    plt.annotate(name + ' (£' + str(int(summary_data['annual_marketing_avg'][i])) + ')',
                 (summary_data['seating_capacity'][i], summary_data['annual_visitors_avg'][i]))
plt.plot([0, 600], [0, 10000], linestyle=':', color='black')
plt.plot([0, 600], [0, 20000], linestyle=':', color='red')
plt.plot([0, 600], [0, 30000], linestyle=':', color='orange')
plt.plot([0, 600],[0, 50000], linestyle=':', color='green')
plt.legend(loc=2, title='Seat fulfillment')
plt.show()

selected =  ['YBS', 'VJV', 'VPG', 'WVA']


# Select only the cinemas of interest
selected_summary_data = summary_data.loc[selected]

# Add a new column for bubble sizes based on the annual marketing average
selected_summary_data['BubbleSize'] = selected_summary_data['annual_marketing_avg'] * 20

# Create the scatter plot
plt.figure(figsize=(8, 8))
plt.scatter(selected_summary_data['annual_visitors_avg'], selected_summary_data['seating_capacity'],
            s=selected_summary_data['BubbleSize'], alpha=0.5)
plt.title('Seating Capacity vs Annual Visitors vs Marketing for high volume Cinemas', fontsize=12)
plt.xlabel('Annual Visitors', fontsize=12)
plt.ylabel('Seating Capacity', fontsize=12)

# Annotate each point with the cinema name and annual marketing average
for i, name in enumerate(selected_summary_data.index):
    plt.annotate(name + ' (£' + str(int(selected_summary_data['annual_marketing_avg'][i])) + ')',
                 (selected_summary_data['annual_visitors_avg'][i] + 300, selected_summary_data['seating_capacity'][i]))

# Draw the marketing spend limits lines
plt.plot([0, 55000], [0, 200], linestyle=':', color='black', label='£2.00 per unit')
plt.plot([0, 55000], [0, 300], linestyle=':', color='red', label='£1.00 per unit')
plt.plot([0, 55000], [0, 400], linestyle=':', color='orange', label='£0.50 per unit')
plt.plot([0, 55000], [0, 500], linestyle=':', color='green', label='£0.25 per unit')
plt.legend(loc=2, title='Marketing spend limits')

# Show the plot
plt.show()

# high plot only taking the few attributes.
# High:

selected_columns = ['seating_capacity','annual_profit', 'annual_visitors_avg', 'annual_marketing_avg']
summary_data_selected = summary_data[selected_columns].copy()

normalised_data = summary_data_selected / summary_data_selected.max()


n_attributes = len(normalised_data.columns)
angles = [n / float(n_attributes) * 2 * np.pi for n in range(n_attributes + 1)]
colours = ['b', 'g', 'r', 'c']
c = 0
plt.figure(figsize=(5, 5))
sub = plt.subplot(1, 1, 1, polar=True)
for name in selected:
    values = normalised_data.loc[[name]].values.flatten().tolist()
    values += values[:1]
    sub.plot(angles, values, colours[c % len(colours)], label=  name)
    sub.fill(angles, values, colours[c % len(colours)], alpha=0.1)
    sub.set_ylim(ymax=1.05)
    sub.set_yticks([0.2, 0.4, 0.6, 0.8, 1.0])
    sub.set_xticks(angles[0:-1])
    sub.set_xticklabels(normalised_data.columns, rotation=45, ha='right', fontsize=10, va='top', rotation_mode='anchor', minor= False)

    c += 1
plt.title("High Volume Cinema Radar Plot")
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()